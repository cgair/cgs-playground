#include <stdarg.h>
#include <sys/syscall.h>
#include <assert.h>

#include <stdio.h>

// Minimum runtime library
long syscall(int num, ...) {
  va_list ap;
  va_start(ap, num);
  register long a0 asm ("rax") = num;
  register long a1 asm ("rdi") = va_arg(ap, long);
  register long a2 asm ("rsi") = va_arg(ap, long);
  register long a3 asm ("rdx") = va_arg(ap, long);
  register long a4 asm ("r10") = va_arg(ap, long);
  va_end(ap);
  asm volatile("syscall"
    : "+r"(a0) : "r"(a1), "r"(a2), "r"(a3), "r"(a4)
    : "memory", "rcx", "r8", "r9", "r11");
  return a0;
}

int main()
{
    int p[2];
    // [What is the difference between char s[] and char *s?](https://stackoverflow.com/questions/1704407/what-is-the-difference-between-char-s-and-char-s)
    // char *sout = "Hello, World!\n";  // sout 是指向第一个字符'H'的一个指针
                                        // "Hello world" is in the read-only parts of the memory, and making sout a pointer to that makes any writing operation on this memory illegal.
    // char sout[] = "Hello, World!\n";    // "Hello, World!\n" 存在于**栈上**, 通过 s[index] = '?' 改变值是合法的.
    // char sin[14];
    char *sout = "a";
    char buf;
    assert(syscall(SYS_pipe, p) >= 0);
    if (syscall(SYS_fork) == 0) {
        syscall(SYS_close, 1);
        syscall(SYS_dup, p[1]);     /* The dup() system call creates a copy of the file descriptor oldfd, using the lowest-numbered unused file descriptor for the new descriptor. (man 2 dup) */
                                    // 这里就是把刚才关闭的 stdout 指向了管道的写口
        syscall(SYS_close, p[0]);
        syscall(SYS_close, p[1]);   // 此时子进程的 stdout 指向了管道的写口
        syscall(SYS_write, 1, sout, 2);
    }
    if (syscall(SYS_fork) == 0) {
        syscall(SYS_close, 0);
        syscall(SYS_dup, p[0]);
        syscall(SYS_close, p[0]);
        syscall(SYS_close, p[1]);   // 此时子进程的 stdin 指向了管道的读口
        while(syscall(SYS_read, 0, &buf, 2) > 0) break;
    }
    
    syscall(SYS_close, p[0]);
    syscall(SYS_close, p[1]);
    syscall(SYS_wait4, -1, 0, 0, 0);  
    syscall(SYS_wait4, -1, 0, 0, 0);    // wait: 等管道左右两边都执行完
    printf("%d\n", buf);
}