// 当进程 exit() 退出之后, 他的父进程没有通过 wait() 系统调用回收其进程描述符的信息,
// 该进程会继续停留在系统的进程表中, 占用内核资源, 这样的进程就是僵尸进程.
#include <unistd.h>
#include <stdio.h>

int main ()
{
    /*fpid 表示 fork 函数返回的值, fork 会返回两次, 
    一次是父进程, 返回值是子进程的Pid, 在子进程会返回0*/
    pid_t fpid;
    fpid=fork(); //fork 后会出现两个分支执行下面的代码, 一个父进程, 一个新的子进程
    if (fpid < 0)
        printf("fork error!");
    else if (fpid == 0) {
        printf("child id is %d\n", getpid());
        sleep(30); //睡眠, 在父进程之前退出
        printf("child is in the end game.\n");
    }
    else { // 父进程
        printf("parent id is %d\n", getpid());
        sleep(60);
        printf("parent is in the end game.\n");
    }
}

/*
1. pstree 查看进程树: a.out(80051)───a.out(80052)
2. 等待子进程退出, 查看子进程的状态: `cat /proc/<Pid>/status`
+-------------------+
|name:   a.out      |
|State:  Z (zombie) |
|Tgid:   80052      |
|Ngid:   0          |
|Pid:    80052      |
|PPid:   80051      |
|...                |
+-------------------+
等到父进程退出之后, 该僵尸进程在系统中找不到了.
父进程退出, 没有为子进程 "收尸", 但是子进程也会一并退出, 怎么做到的呢? 这就涉及到了孤儿进程.
*/