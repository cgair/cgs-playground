#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int main(int argc, char *argv[]) {
  print_hello();
  int n = 2;
  for (int i = 0; i < n; i++) {
    fork();
    printf("Hello\n");
  }
  for (int i = 0; i < n; i++) {
    wait(NULL);
  }
}

/*
状态机1: 
+-------------+
|  i=0. fork  |
+-------------+
       | fork
       V   
+-------------+
|i=0. printfx2| -> Hello Hello
+-------------+
       | fork
       V   
+-------------+
|  i=1. fork  |
+-------------+
       | fork
       V     
+-------------+
|i=1. printfx4| -> Hello Hello Hello Hello
+-------------+
所以应该打印 6 个 Hello, 然而 `./a,out | wc -l` OR `./a,out | cat` 是 8 个.
因为我们假设当运行 `printf("Hello\n");` 就会打印一个 "Hello". 
实际上, call print_hello 并没有打印 "Hello". (因为缓冲区)
我们的标准输出 stdout:
* 如果是终端 tty           -> line buffer (看到 '\n' 就会 syscall 写)
* 如果是管道/文件 pipe/file -> full buffer (等到 4096 字节才写)

fork 是无情的复制状态的机器(所有的寄存器所有内存)
*/
void print_hello() {
  printf("Hello\n");
  // fflush(stdout);  // 要 call fflush
  int *p;
  p = NULL;
  *p = 1;   // 非法操作, crash(Segmentation fault)
}
